---
title: Collection View Generator (`generate_collections.py`)
standard_id: OM-DOC-TOOLS-BUILDER-README # Changed standard_id
aliases:
  - Builder README
tags:
  - status/active
  - content-type/documentation
  - topic/readme
  - kb-id/tools
kb-id: "kb-id/tools" # Standardized kb-id format
info-type: "guide-document" # Ensured info-type
primary-topic: Overview and guidance for the builder directory and its contents.
related-standards: []
version: 1.0.0
date-created: '2025-06-01T11:33:47Z'
date-modified: '2025-06-02T00:00:00Z'
primary_domain: "OM" # Changed primary_domain
sub_domain: "DOCUMENTATION" # Changed sub_domain
scope_application: Provides an overview for the /app/master-knowledge-base/tools/builder directory and its script.
criticality: "P3-Low" # Changed criticality
lifecycle_gatekeeper: No-Gatekeeper
impact_areas:
  - documentation
  - usability
change_log_url: https://example.com/placeholder-changelog-url # Changed change_log_url
---

# Collection View Generator (`generate_collections.py`)

## Purpose

The `generate_collections.py` script is designed to build "Collection Documents" or "Derived Views." These are single Markdown documents that aggregate content from multiple atomic standard documents, based on defined criteria. This allows for the creation of curated views of standards, such as "All Architecture Standards" or "All Security-Related Policies."

## Planned Features & Specifications

1.  **Input:**
    *   **`standards_index.json`**: Consumes the JSON index file generated by the `/tools/indexer/generate_index.py` script. This provides the metadata for all available atomic standards.
    *   **`collection_definitions.yaml` (or similar configuration file):** A configuration file (likely YAML) that defines the collections to be built. Each definition includes:
        *   A unique ID for the collection.
        *   A `title` for the generated collection document.
        *   An `output_filename` for the generated Markdown file.
        *   A `description` for the collection.
        *   Filtering `criteria` to select which standards from the `standards_index.json` belong to this collection. Criteria can be based on fields like `primary_domain`, `sub_domain`, `tags`, `info-type`, `status`, etc., using operators like `equals`, `in`, `contains`.

2.  **Core Logic:**
    *   Loads and validates the `standards_index.json`.
    *   Loads and parses the `collection_definitions.yaml`.
    *   For each collection defined in the configuration:
        *   Filters the list of standards from the index based on the specified criteria.
        *   For each standard document that matches the criteria:
            *   Reads the content of the Markdown file (the path is available from the index).
            *   Extracts the relevant body content (e.g., excluding the original frontmatter, or potentially only specific H2 sections based on more advanced rules).
        *   Aggregates the extracted content from all selected standards into a single Markdown string.
        *   Generates a Table of Contents (ToC) at the beginning of the collection document, linking to the start of each included standard's content using internal page anchors.
        *   **Internal Link Resolution (Advanced):**
            *   Identifies `[[STANDARD_ID]]` links within the aggregated content.
            *   If the `TARGET_ID` of a link is also part of the *same generated collection document*, the link is transformed into an internal anchor link (e.g., `[Link Text](#target_id_anchor)`).
            *   If the `TARGET_ID` points to a standard *not* in the current collection, the link might remain as `[[TARGET_ID]]` (to be resolved by a site generator) or, if possible, be transformed into a relative link to another generated collection file where that standard might reside. This requires careful planning of collection scopes.

3.  **Output:**
    *   Generates individual Markdown files for each defined collection.
    *   These files are saved to a specified output directory (e.g., `/dist/collections/` or `/site/collections/`). This output directory should typically be added to `.gitignore` as it contains derived, not source, content.
    *   Each generated collection document will have its own YAML frontmatter, including:
        *   `title` (from the collection definition).
        *   `date_generated` (ISO-8601 timestamp).
        *   `source_collection_definition` (the ID of the collection rule that generated it).
        *   `number_of_standards` (count of aggregated standards).
        *   Relevant tags like `kb-collection`, `derived-view`.

## Usage

The script is executed from the command line.

```bash
python generate_collections.py [OPTIONS]
```

### Command-Line Arguments:

*   `--repo-base REPO_BASE`:
    *   Base directory of the repository.
    *   Default: `.` (current directory)
*   `--index-file INDEX_FILE`:
    *   Path to the standards index JSON file, relative to `repo-base`.
    *   Default: `master-knowledge-base/dist/standards_index.json`
*   `--definitions-file DEFINITIONS_FILE`:
    *   Path to the collection definitions YAML file, relative to `repo-base`.
    *   Default: `master-knowledge-base/tools/builder/collection_definitions.yaml`
*   `--output-dir OUTPUT_DIR`:
    *   Directory to save generated collection files, relative to `repo-base`.
    *   Default: `master-knowledge-base/dist/collections`
*   `--log-level LOG_LEVEL`:
    *   Set the logging level.
    *   Choices: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
    *   Default: `INFO`

### Example:

```bash
# Run with default settings (assuming script is run from repo root)
python master-knowledge-base/tools/builder/generate_collections.py

# Run with a different repo base and debug logging
python master-knowledge-base/tools/builder/generate_collections.py --repo-base /path/to/your/repo --log-level DEBUG

# Specify a different output directory
python master-knowledge-base/tools/builder/generate_collections.py --output-dir master-knowledge-base/dist/custom_collections
```

## Development Status

The script has been enhanced with command-line argument parsing using `argparse` and structured logging using the `logging` module. Print statements have been replaced with logger calls.

Key functional areas that are largely implemented:
-   Loading and validation of the YAML configuration file for collection definitions.
-   Loading the standards index.
-   Basic filtering logic based on criteria (currently AND logic for all criteria).
-   File content reading and extraction of body content (after frontmatter).
-   Table of Contents generation with GFM anchors (including basic duplicate anchor handling).
-   Aggregation of content into collection Markdown files.
-   Basic internal link resolution for links pointing to standards within the same collection.

Potential areas for future improvement:
-   More complex criteria logic (e.g., AND/OR groups) for filtering standards.
-   More sophisticated internal link resolution (e.g., across different generated collections).
-   Handling of different content extraction rules (e.g., specific H2 sections).

The script uses paths relative to the specified `repo-base` (or current directory if not specified).
The output directory is created if it doesn't exist.
The `/master-knowledge-base/dist/` directory (which includes the default output for collections and the default standards_index.json) should typically be added to `.gitignore`.
An example `collection_definitions.yaml` should be maintained in the `master-knowledge-base/tools/builder/` directory.
