---
title: Collection View Generator (`generate_collections.py`)
standard_id: DOC-TOOLS-BUILDER-README
aliases:
  - Builder README
tags:
  - status/active
  - content-type/documentation
  - topic/readme
  - kb-id/tools
kb-id: tools
info-type: guide-document
primary-topic: Overview and guidance for the builder directory and its contents.
related-standards: []
version: 1.0.0
date-created: '2025-06-01T11:33:47Z'
date-modified: '2025-06-01T11:33:47Z'
primary_domain: GM
sub_domain: GUIDE
scope_application: Provides an overview for the /app/master-knowledge-base/tools/builder/README.md.
criticality: P4-Informational
lifecycle_gatekeeper: No-Gatekeeper
impact_areas:
  - documentation
  - usability
change_log_url: ./README-CHANGELOG.MD
---

# Collection View Generator (`generate_collections.py`)

## Purpose

The `generate_collections.py` script is designed to build "Collection Documents" or "Derived Views." These are single Markdown documents that aggregate content from multiple atomic standard documents, based on defined criteria. This allows for the creation of curated views of standards, such as "All Architecture Standards" or "All Security-Related Policies."

## Planned Features & Specifications

1.  **Input:**
    *   **`standards_index.json`**: Consumes the JSON index file generated by the `/tools/indexer/generate_index.py` script. This provides the metadata for all available atomic standards.
    *   **`collection_definitions.yaml` (or similar configuration file):** A configuration file (likely YAML) that defines the collections to be built. Each definition includes:
        *   A unique ID for the collection.
        *   A `title` for the generated collection document.
        *   An `output_filename` for the generated Markdown file.
        *   A `description` for the collection.
        *   Filtering `criteria` to select which standards from the `standards_index.json` belong to this collection. Criteria can be based on fields like `primary_domain`, `sub_domain`, `tags`, `info-type`, `status`, etc., using operators like `equals`, `in`, `contains`.

2.  **Core Logic:**
    *   Loads and validates the `standards_index.json`.
    *   Loads and parses the `collection_definitions.yaml`.
    *   For each collection defined in the configuration:
        *   Filters the list of standards from the index based on the specified criteria.
        *   For each standard document that matches the criteria:
            *   Reads the content of the Markdown file (the path is available from the index).
            *   Extracts the relevant body content (e.g., excluding the original frontmatter, or potentially only specific H2 sections based on more advanced rules).
        *   Aggregates the extracted content from all selected standards into a single Markdown string.
        *   Generates a Table of Contents (ToC) at the beginning of the collection document, linking to the start of each included standard's content using internal page anchors.
        *   **Internal Link Resolution (Advanced):**
            *   Identifies `[[STANDARD_ID]]` links within the aggregated content.
            *   If the `TARGET_ID` of a link is also part of the *same generated collection document*, the link is transformed into an internal anchor link (e.g., `[Link Text](#target_id_anchor)`).
            *   If the `TARGET_ID` points to a standard *not* in the current collection, the link might remain as `[[TARGET_ID]]` (to be resolved by a site generator) or, if possible, be transformed into a relative link to another generated collection file where that standard might reside. This requires careful planning of collection scopes.

3.  **Output:**
    *   Generates individual Markdown files for each defined collection.
    *   These files are saved to a specified output directory (e.g., `/dist/collections/` or `/site/collections/`). This output directory should typically be added to `.gitignore` as it contains derived, not source, content.
    *   Each generated collection document will have its own YAML frontmatter, including:
        *   `title` (from the collection definition).
        *   `date_generated` (ISO-8601 timestamp).
        *   `source_collection_definition` (the ID of the collection rule that generated it).
        *   `number_of_standards` (count of aggregated standards).
        *   Relevant tags like `kb-collection`, `derived-view`.

## Usage (Conceptual)

```bash
python generate_collections.py 
# (Optionally, in the future: python generate_collections.py --index /path/to/index.json --config /path/to/collections.yaml --out /path/to/output/dir)
```

## Development Status

This script is currently a skeleton with defined specifications. Key areas for implementation include:
-   Robust loading and validation of the YAML configuration file for collection definitions.
-   Implementation of the filtering logic based on various criteria and operators.
-   Actual file content reading and extraction (beyond just metadata).
-   Sophisticated Table of Contents generation.
-   Advanced internal link resolution logic.
-   Error handling and logging.

The current skeleton includes placeholders for these functionalities and basic file/directory handling. The path for `standards_index.json` and `collection_definitions.yaml` are set relative to an assumed repository root from the script's location.
The output directory `/dist/collections/` is created if it doesn't exist.
The example `collection_definitions.yaml` should be created alongside this script.
